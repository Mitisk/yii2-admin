const iterate=(object,callback)=>{if(Array.isArray(object)){object.forEach(callback)}else{for(var key in object){if(object.hasOwnProperty(key)){callback(object[key],key)}}}};const removeClasses=(elmts,...classes)=>{var norm_classes=classesArray(classes);elmts=castAsArray(elmts);elmts.map(el=>{norm_classes.map(cls=>{el.classList.remove(cls)})})};const classesArray=args=>{var classes=[];iterate(args,_classes=>{if(typeof _classes==="string"){_classes=_classes.trim().split(/[\t\n\f\r\s]/)}if(Array.isArray(_classes)){classes=classes.concat(_classes)}});return classes.filter(Boolean)};const castAsArray=arg=>{if(!Array.isArray(arg)){arg=[arg]}return arg};const nodeIndex=(el,amongst)=>{if(!el)return-1;amongst=amongst||el.nodeName;var i=0;while(el=el.previousElementSibling){if(el.matches(amongst)){i++}}return i};function plugin(){var self=this;self.hook("instead","setCaret",new_pos=>{if(self.settings.mode==="single"||!self.control.contains(self.control_input)){new_pos=self.items.length}else{new_pos=Math.max(0,Math.min(self.items.length,new_pos));if(new_pos!=self.caretPos&&!self.isPending){self.controlChildren().forEach((child,j)=>{if(j<new_pos){self.control_input.insertAdjacentElement("beforebegin",child)}else{self.control.appendChild(child)}})}}self.caretPos=new_pos});self.hook("instead","moveCaret",direction=>{if(!self.isFocused)return;const last_active=self.getLastActive(direction);if(last_active){const idx=nodeIndex(last_active);self.setCaret(direction>0?idx+1:idx);self.setActiveItem();removeClasses(last_active,"last-active")}else{self.setCaret(self.caretPos+direction)}})}export{plugin as default};