(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,factory(global.sifter={}))})(this,function(exports){"use strict";const arrayToPattern=chars=>{chars=chars.filter(Boolean);if(chars.length<2){return chars[0]||""}return maxValueLength(chars)==1?"["+chars.join("")+"]":"(?:"+chars.join("|")+")"};const sequencePattern=array=>{if(!hasDuplicates(array)){return array.join("")}let pattern="";let prev_char_count=0;const prev_pattern=()=>{if(prev_char_count>1){pattern+="{"+prev_char_count+"}"}};array.forEach((char,i)=>{if(char===array[i-1]){prev_char_count++;return}prev_pattern();pattern+=char;prev_char_count=1});prev_pattern();return pattern};const setToPattern=chars=>{let array=Array.from(chars);return arrayToPattern(array)};const hasDuplicates=array=>{return new Set(array).size!==array.length};const escape_regex=str=>{return(str+"").replace(/([\$\(-\+\.\?\[-\^\{-\}])/g,"\\$1")};const maxValueLength=array=>{return array.reduce((longest,value)=>Math.max(longest,unicodeLength(value)),0)};const unicodeLength=str=>{return Array.from(str).length};const allSubstrings=input=>{if(input.length===1)return[[input]];let result=[];const start=input.substring(1);const suba=allSubstrings(start);suba.forEach(function(subresult){let tmp=subresult.slice(0);tmp[0]=input.charAt(0)+tmp[0];result.push(tmp);tmp=subresult.slice(0);tmp.unshift(input.charAt(0));result.push(tmp)});return result};const code_points=[[0,65535]];const accent_pat="[̀-ͯ·ʾʼ]";let unicode_map;let multi_char_reg;const max_char_length=3;const latin_convert={};const latin_condensed={"/":"⁄∕",0:"߀",a:"ⱥɐɑ",aa:"ꜳ",ae:"æǽǣ",ao:"ꜵ",au:"ꜷ",av:"ꜹꜻ",ay:"ꜽ",b:"ƀɓƃ",c:"ꜿƈȼↄ",d:"đɗɖᴅƌꮷԁɦ",e:"ɛǝᴇɇ",f:"ꝼƒ",g:"ǥɠꞡᵹꝿɢ",h:"ħⱨⱶɥ",i:"ɨı",j:"ɉȷ",k:"ƙⱪꝁꝃꝅꞣ",l:"łƚɫⱡꝉꝇꞁɭ",m:"ɱɯϻ",n:"ꞥƞɲꞑᴎлԉ",o:"øǿɔɵꝋꝍᴑ",oe:"œ",oi:"ƣ",oo:"ꝏ",ou:"ȣ",p:"ƥᵽꝑꝓꝕρ",q:"ꝗꝙɋ",r:"ɍɽꝛꞧꞃ",s:"ßȿꞩꞅʂ",t:"ŧƭʈⱦꞇ",th:"þ",tz:"ꜩ",u:"ʉ",v:"ʋꝟʌ",vy:"ꝡ",w:"ⱳ",y:"ƴɏỿ",z:"ƶȥɀⱬꝣ",hv:"ƕ"};for(let latin in latin_condensed){let unicode=latin_condensed[latin]||"";for(let i=0;i<unicode.length;i++){let char=unicode.substring(i,i+1);latin_convert[char]=latin}}const convert_pat=new RegExp(Object.keys(latin_convert).join("|")+"|"+accent_pat,"gu");const initialize=_code_points=>{if(unicode_map!==undefined)return;unicode_map=generateMap(code_points)};const normalize=(str,form="NFKD")=>str.normalize(form);const asciifold=str=>{return Array.from(str).reduce((result,char)=>{return result+_asciifold(char)},"")};const _asciifold=str=>{str=normalize(str).toLowerCase().replace(convert_pat,char=>{return latin_convert[char]||""});return normalize(str,"NFC")};function*generator(code_points){for(const[code_point_min,code_point_max]of code_points){for(let i=code_point_min;i<=code_point_max;i++){let composed=String.fromCharCode(i);let folded=asciifold(composed);if(folded==composed.toLowerCase()){continue}if(folded.length>max_char_length){continue}if(folded.length==0){continue}yield{folded:folded,composed:composed,code_point:i}}}}const generateSets=code_points=>{const unicode_sets={};const addMatching=(folded,to_add)=>{const folded_set=unicode_sets[folded]||new Set;const patt=new RegExp("^"+setToPattern(folded_set)+"$","iu");if(to_add.match(patt)){return}folded_set.add(escape_regex(to_add));unicode_sets[folded]=folded_set};for(let value of generator(code_points)){addMatching(value.folded,value.folded);addMatching(value.folded,value.composed)}return unicode_sets};const generateMap=code_points=>{const unicode_sets=generateSets(code_points);const unicode_map={};let multi_char=[];for(let folded in unicode_sets){let set=unicode_sets[folded];if(set){unicode_map[folded]=setToPattern(set)}if(folded.length>1){multi_char.push(escape_regex(folded))}}multi_char.sort((a,b)=>b.length-a.length);const multi_char_patt=arrayToPattern(multi_char);multi_char_reg=new RegExp("^"+multi_char_patt,"u");return unicode_map};const mapSequence=(strings,min_replacement=1)=>{let chars_replaced=0;strings=strings.map(str=>{if(unicode_map[str]){chars_replaced+=str.length}return unicode_map[str]||str});if(chars_replaced>=min_replacement){return sequencePattern(strings)}return""};const substringsToPattern=(str,min_replacement=1)=>{min_replacement=Math.max(min_replacement,str.length-1);return arrayToPattern(allSubstrings(str).map(sub_pat=>{return mapSequence(sub_pat,min_replacement)}))};const sequencesToPattern=(sequences,all=true)=>{let min_replacement=sequences.length>1?1:0;return arrayToPattern(sequences.map(sequence=>{let seq=[];const len=all?sequence.length():sequence.length()-1;for(let j=0;j<len;j++){seq.push(substringsToPattern(sequence.substrs[j]||"",min_replacement))}return sequencePattern(seq)}))};const inSequences=(needle_seq,sequences)=>{for(const seq of sequences){if(seq.start!=needle_seq.start||seq.end!=needle_seq.end){continue}if(seq.substrs.join("")!==needle_seq.substrs.join("")){continue}let needle_parts=needle_seq.parts;const filter=part=>{for(const needle_part of needle_parts){if(needle_part.start===part.start&&needle_part.substr===part.substr){return false}if(part.length==1||needle_part.length==1){continue}if(part.start<needle_part.start&&part.end>needle_part.start){return true}if(needle_part.start<part.start&&needle_part.end>part.start){return true}}return false};let filtered=seq.parts.filter(filter);if(filtered.length>0){continue}return true}return false};class Sequence{constructor(){this.parts=void 0;this.substrs=void 0;this.start=void 0;this.end=void 0;this.parts=[];this.substrs=[];this.start=0;this.end=0}add(part){if(part){this.parts.push(part);this.substrs.push(part.substr);this.start=Math.min(part.start,this.start);this.end=Math.max(part.end,this.end)}}last(){return this.parts[this.parts.length-1]}length(){return this.parts.length}clone(position,last_piece){let clone=new Sequence;let parts=JSON.parse(JSON.stringify(this.parts));let last_part=parts.pop();for(const part of parts){clone.add(part)}let last_substr=last_piece.substr.substring(0,position-last_part.start);let clone_last_len=last_substr.length;clone.add({start:last_part.start,end:last_part.start+clone_last_len,length:clone_last_len,substr:last_substr});return clone}}const getPattern=str=>{initialize();str=asciifold(str);let pattern="";let sequences=[new Sequence];for(let i=0;i<str.length;i++){let substr=str.substring(i);let match=substr.match(multi_char_reg);const char=str.substring(i,i+1);const match_str=match?match[0]:null;let overlapping=[];let added_types=new Set;for(const sequence of sequences){const last_piece=sequence.last();if(!last_piece||last_piece.length==1||last_piece.end<=i){if(match_str){const len=match_str.length;sequence.add({start:i,end:i+len,length:len,substr:match_str});added_types.add("1")}else{sequence.add({start:i,end:i+1,length:1,substr:char});added_types.add("2")}}else if(match_str){let clone=sequence.clone(i,last_piece);const len=match_str.length;clone.add({start:i,end:i+len,length:len,substr:match_str});overlapping.push(clone)}else{added_types.add("3")}}if(overlapping.length>0){overlapping=overlapping.sort((a,b)=>{return a.length()-b.length()});for(let clone of overlapping){if(inSequences(clone,sequences)){continue}sequences.push(clone)}continue}if(i>0&&added_types.size==1&&!added_types.has("3")){pattern+=sequencesToPattern(sequences,false);let new_seq=new Sequence;const old_seq=sequences[0];if(old_seq){new_seq.add(old_seq.last())}sequences=[new_seq]}}pattern+=sequencesToPattern(sequences,true);return pattern};const getAttr=(obj,name)=>{if(!obj)return;return obj[name]};const getAttrNesting=(obj,name)=>{if(!obj)return;var part,names=name.split(".");while((part=names.shift())&&(obj=obj[part]));return obj};const scoreValue=(value,token,weight)=>{var score,pos;if(!value)return 0;value=value+"";if(token.regex==null)return 0;pos=value.search(token.regex);if(pos===-1)return 0;score=token.string.length/value.length;if(pos===0)score+=.5;return score*weight};const propToArray=(obj,key)=>{var value=obj[key];if(typeof value=="function")return value;if(value&&!Array.isArray(value)){obj[key]=[value]}};const iterate=(object,callback)=>{if(Array.isArray(object)){object.forEach(callback)}else{for(var key in object){if(object.hasOwnProperty(key)){callback(object[key],key)}}}};const cmp=(a,b)=>{if(typeof a==="number"&&typeof b==="number"){return a>b?1:a<b?-1:0}a=asciifold(a+"").toLowerCase();b=asciifold(b+"").toLowerCase();if(a>b)return 1;if(b>a)return-1;return 0};class Sifter{constructor(items,settings){this.items=items;this.settings=settings||{diacritics:true}}tokenize(query,respect_word_boundaries,weights){if(!query||!query.length)return[];const tokens=[];const words=query.split(/\s+/);var field_regex;if(weights){field_regex=new RegExp("^("+Object.keys(weights).map(escape_regex).join("|")+"):(.*)$")}words.forEach(word=>{let field_match;let field=null;let regex=null;if(field_regex&&(field_match=word.match(field_regex))){field=field_match[1];word=field_match[2]}if(word.length>0){if(this.settings.diacritics){regex=getPattern(word)||null}else{regex=escape_regex(word)}if(regex&&respect_word_boundaries)regex="\\b"+regex}tokens.push({string:word,regex:regex?new RegExp(regex,"iu"):null,field:field})});return tokens}getScoreFunction(query,options){var search=this.prepareSearch(query,options);return this._getScoreFunction(search)}_getScoreFunction(search){const tokens=search.tokens,token_count=tokens.length;if(!token_count){return function(){return 0}}const fields=search.options.fields,weights=search.weights,field_count=fields.length,getAttrFn=search.getAttrFn;if(!field_count){return function(){return 1}}const scoreObject=function(){if(field_count===1){return function(token,data){const field=fields[0].field;return scoreValue(getAttrFn(data,field),token,weights[field]||1)}}return function(token,data){var sum=0;if(token.field){const value=getAttrFn(data,token.field);if(!token.regex&&value){sum+=1/field_count}else{sum+=scoreValue(value,token,1)}}else{iterate(weights,(weight,field)=>{sum+=scoreValue(getAttrFn(data,field),token,weight)})}return sum/field_count}}();if(token_count===1){return function(data){return scoreObject(tokens[0],data)}}if(search.options.conjunction==="and"){return function(data){var score,sum=0;for(let token of tokens){score=scoreObject(token,data);if(score<=0)return 0;sum+=score}return sum/token_count}}else{return function(data){var sum=0;iterate(tokens,token=>{sum+=scoreObject(token,data)});return sum/token_count}}}getSortFunction(query,options){var search=this.prepareSearch(query,options);return this._getSortFunction(search)}_getSortFunction(search){var implicit_score,sort_flds=[];const self=this,options=search.options,sort=!search.query&&options.sort_empty?options.sort_empty:options.sort;if(typeof sort=="function"){return sort.bind(this)}const get_field=function get_field(name,result){if(name==="$score")return result.score;return search.getAttrFn(self.items[result.id],name)};if(sort){for(let s of sort){if(search.query||s.field!=="$score"){sort_flds.push(s)}}}if(search.query){implicit_score=true;for(let fld of sort_flds){if(fld.field==="$score"){implicit_score=false;break}}if(implicit_score){sort_flds.unshift({field:"$score",direction:"desc"})}}else{sort_flds=sort_flds.filter(fld=>fld.field!=="$score")}const sort_flds_count=sort_flds.length;if(!sort_flds_count){return null}return function(a,b){var result,field;for(let sort_fld of sort_flds){field=sort_fld.field;let multiplier=sort_fld.direction==="desc"?-1:1;result=multiplier*cmp(get_field(field,a),get_field(field,b));if(result)return result}return 0}}prepareSearch(query,optsUser){const weights={};var options=Object.assign({},optsUser);propToArray(options,"sort");propToArray(options,"sort_empty");if(options.fields){propToArray(options,"fields");const fields=[];options.fields.forEach(field=>{if(typeof field=="string"){field={field:field,weight:1}}fields.push(field);weights[field.field]="weight"in field?field.weight:1});options.fields=fields}return{options:options,query:query.toLowerCase().trim(),tokens:this.tokenize(query,options.respect_word_boundaries,weights),total:0,items:[],weights:weights,getAttrFn:options.nesting?getAttrNesting:getAttr}}search(query,options){var self=this,score,search;search=this.prepareSearch(query,options);options=search.options;query=search.query;const fn_score=options.score||self._getScoreFunction(search);if(query.length){iterate(self.items,(item,id)=>{score=fn_score(item);if(options.filter===false||score>0){search.items.push({score:score,id:id})}})}else{iterate(self.items,(_,id)=>{search.items.push({score:1,id:id})})}const fn_sort=self._getSortFunction(search);if(fn_sort)search.items.sort(fn_sort);search.total=search.items.length;if(typeof options.limit==="number"){search.items=search.items.slice(0,options.limit)}return search}}exports.Sifter=Sifter;exports.cmp=cmp;exports.getAttr=getAttr;exports.getAttrNesting=getAttrNesting;exports.getPattern=getPattern;exports.iterate=iterate;exports.propToArray=propToArray;exports.scoreValue=scoreValue});